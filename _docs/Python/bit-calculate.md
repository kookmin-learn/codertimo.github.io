---
title: 비트 연산
category : Python
order: 6
layout: default
comments: true
---

참고 소스 : [kookmin-learn/bit-calculate.py](https://github.com/codertimo/kookmin-learn/blob/master/bit-calculate.py)

## 비트란
비트는 0과 1을 나타낼 수 있는 가장 작은 데이터 단위이다. 음, 2진수로도 생각할 수 있는데 예를 들어서 **4를 이진수로 나타내면** 0100으로 나타 낼 수 있다.

|  | 2^3 (8) | 2^2 (4) | 2^1(2) | 2^0(1) |
| ---- | --- | --- | --- | --- | --- |
| 2진수(bit) | 0 | 1 | 0 | 0 |
| 10진수 | 0 | 4 | 0 | 0 | 합 :4|


0(2^3),1(2^2),0(2^1),(2^0)을 다 더하면 4가 된다. 10진수를 2진수로 바꾸는 방법은 옆에 링크를 참조하면 될듯 하다. [링크 : 10진수를 2진수로 바꾸는 방법](http://meaningone.tistory.com/606)

## 바이트
비트는 2가지 정보밖에 알 수 없기에 매우 작은 단위이다. 그래서 보통 비트 8개를 모아서 사용하는데, 0000 0000 이렇게 총 8개의 비트를 한 묶음으로 사용한다. 이 **8개의 비트의 묶음을 1byte** 라고 한다.

| 바이트 | 1byte | 2byte | 3byte | 4byte |
| ---- | --- | --- | --- | --- | --- |
| 비트 | 8bit | 16bit | 32bit | 64bit |

## 비트 연산자

먼저```a = 60, b = 13 ``` 라고 하자
그럼 **a와 b는 아래처럼 2진수로 바꿀 수 있다.** 여기서부터 하나하나 배워보자
```
a = 0011 1100
b = 0000 1101
```

### & 연산자
AND 연산. a와 b 둘다 1일때만 참(1)

| a&b | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 |
| ---- | --- | --- | --- | --- | --- |
| b | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
| a | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |

### | 연산자
OR 연산. a 와 b 둘중 하나라도 1이라면 참(1)

| ab | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 |
| ---- | --- | --- | --- | --- | --- |
| b | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
| a | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |

### ^ 연산자
XOR 연산. a 와 b 중 하나만 1일때 참(1), 둘다 1이면 참 x

| a^b | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
| ---- | --- | --- | --- | --- | --- |
| b | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
| a | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |

### ~ 연산자
보수 연산. 보수는 0과 1을 바꿔보면 된다.

| ~a | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 1 |
| ---- | --- | --- | --- | --- | --- |
| a | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |

| ~b | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 0 |
| ---- | --- | --- | --- | --- | --- |
| b | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |

### ```<<``` 연산자
쉬프트 연산. 컨베이어 벨트처럼, 비트를 왼쪽으로 n번 밀면됩니다.

| ```a<<1``` | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| ---- | --- | --- | --- | --- | --- |
| a | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |

| ```b<<2``` | 0 | 0 | 1 | 1 | 0 | 1 | 0 | 0 |
| ---- | --- | --- | --- | --- | --- |
| b | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
이때 결과값은 (피연산자) * (2의 n승)이 된다.

 또한 제일 왼쪽에 있는 비트가 ```<<```로 **밀려서 밖으로 밀려나는 현상을 Overflow** 라고 한다.

### ```>>```연산자

쉬프트 연산. 위 와같은 종류의 연산자로써 이 연산자는 비트를 오른쪽으로 n번 밀면됩니다.

| ```a>>1``` | 	0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| ---- | --- | --- | --- | --- | --- |
| a | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |

| ```b>>2``` | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| ---- | --- | --- | --- | --- | --- |
| b | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |

이때 결과값은 (피연산자) * (1/2 의 n승)이 된다.

 또한 제일 오른쪽에 있는 비트가 ```>>```로 **밀려서 밖으로 밀려나는 현상을 Underflow** 라고 한다.

### 마스크(Mask) 연산

마스크 연산은 특정 위치에 있는 비트의 값을 알기위한 연산입니다.

| a | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| ---- | --- | --- | --- | --- | --- |
| ```1 & a>>(2-1)``` | 0 |
```1 & (M >> N-1)``` 으로 마스크 연산을 한다면 M의 N번째 비트의 값이 무엇인지 알 수 있습니다.